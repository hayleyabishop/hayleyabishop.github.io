<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reorderable Chord Tags</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }

      "" .tag-container {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .tag {
        padding: 5px 10px;
        background-color: #007bff;
        color: white;
        border-radius: 20px;
        display: inline-flex;
        align-items: center;
        cursor: move;
        opacity: 0;
        transform: scale(0.95);
        transition: all 0.3s ease;
        animation: fadeIn 0.3s forwards; /* Animation for appearance */
      }

      .tag.dragging {
        opacity: 0.5; /* Fade when dragging */
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.95);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      @keyframes fadeOut {
        from {
          opacity: 1;
          transform: scale(1);
        }
        to {
          opacity: 0;
          transform: scale(0.95);
        }
      }

      .tag span {
        margin-right: 10px;
      }

      .tag button {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
      }

      .chordInput {
        margin-bottom: 20px;
      }

      .tag-container.dragging {
        background-color: #f1f1f1;
      }
    </style>
  </head>
  <body>
    <h2>Reorderable Chord Tags</h2>

    <select name="" id="chordInput" class="chordInput">
      <option value=""></option>
      <option value="A">A</option>
      <option value="A# / Bb">A# / Bb</option>
      <option value="B">B</option>
      <option value="C">C</option>
      <option value="C# / Db">C# / Db</option>
      <option value="D">D</option>
      <option value="D# / Eb">D# / Eb</option>
      <option value="E">E</option>
      <option value="F">F</option>
      <option value="F# / Gb">F# / Gb</option>
      <option value="G">G</option>
      <option value="G# / Ab">G# / Ab</option>
    </select>

    <div class="tag-container" id="tagContainer"></div>

    <script>
      const selectElement = document.getElementById("chordInput");
      const tagContainer = document.getElementById("tagContainer");
      let draggedTag = null;

      selectElement.addEventListener("change", function () {
        const selectedValue = this.value;
        if (selectedValue !== "") {
          createTag(selectedValue);
          this.value = ""; // Reset select input after adding a tag
        }
      });

      function createTag(chord) {
        // Create the tag element
        const tag = document.createElement("div");
        tag.classList.add("tag");
        tag.setAttribute("role", "listitem"); // ARIA role for list item
        tag.setAttribute("aria-grabbed", "false"); // Not grabbed yet
        tag.setAttribute("draggable", true);
        tag.innerHTML = `<span>${chord}</span><button onclick="removeTag(this)" aria-label="Remove ${chord} tag">x</button>`;

        // Add drag event listeners
        tag.addEventListener("dragstart", handleDragStart);
        tag.addEventListener("dragover", handleDragOver);
        tag.addEventListener("drop", handleDrop);
        tag.addEventListener("dragend", handleDragEnd);

        // Append the tag to the container
        tagContainer.appendChild(tag);

        // Add ARIA role for tag container if not already set
        tagContainer.setAttribute("role", "list");
      }

      function handleDragStart(e) {
        draggedTag = this;
        this.setAttribute("aria-grabbed", "true"); // Update ARIA attribute when grabbed
        setTimeout(() => this.classList.add("dragging"), 0); // Delay to apply dragging effect
      }

      function removeTag(button) {
        const tag = button.parentElement;
        tag.setAttribute("aria-hidden", "true"); // ARIA hidden for accessibility during removal
        tag.style.animation = "fadeOut 0.3s forwards"; // Fade out animation

        // Wait for the animation to complete before removing the element
        tag.addEventListener("animationend", () => {
          tagContainer.removeChild(tag);
        });
      }

      function handleDragStart(e) {
        draggedTag = this;
        setTimeout(() => this.classList.add("dragging"), 0);
      }

      function handleDragOver(e) {
        e.preventDefault(); // Prevent default to allow drop
        const afterElement = getDragAfterElement(tagContainer, e.clientX);
        if (
          afterElement == null &&
          tagContainer.lastElementChild !== draggedTag
        ) {
          tagContainer.appendChild(draggedTag);
        } else {
          // Only reorder if the element is actually moving
          if (draggedTag !== afterElement.previousSibling) {
            tagContainer.insertBefore(draggedTag, afterElement);
          }
        }
      }

      function handleDrop() {
        this.classList.remove("dragging");
      }

      function handleDragEnd() {
        this.setAttribute("aria-grabbed", "false"); // Reset ARIA attribute when dropped
        this.classList.remove("dragging");
        draggedTag = null;
      }

      function getDragAfterElement(container, x) {
        const draggableElements = [
          ...container.querySelectorAll(".tag:not(.dragging)"),
        ];
        return draggableElements.reduce(
          (closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = x - box.left - box.width / 2;
            if (offset < 0 && offset > closest.offset) {
              return { offset: offset, element: child };
            } else {
              return closest;
            }
          },
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      }
    </script>
  </body>
</html>
